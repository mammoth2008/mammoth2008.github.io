6. 数据库保护
6.2 数据库完整性

### 数据库的完整性
- 数据的正确性: 数据符合现实世界的语义
- 数据的相容性: 同一对象在不同关系表中的数据符合逻辑
- 旨在防止数据库中存在不符合语义的数据

### 维护数据库完整性
- 提供定义完整性约束条件的机制
- 提供完整性检查的方法
- 进行违约处理

### 完整性检查
- 耗费时间和资源
- 由数据库管理系统实现

### 数据库完整性
- 实体完整性
- 参照完整性
- 用户定义的完整性

### 实体完整性
- 在 CREATE TABLE 语句中使用 PRIMARY KEY 短语
- 在列级别定义约束条件
- 在表级别定义约束条件

### 实体完整性检查
- 主码值是否唯一
- 主码的各个属性是否为空
- 通常会在主码上自动创建索引

### 参照完整性
- 在 CREATE TABLE 语句中使用 FOREIGN KEY 和 REFERENCES 短语
- FOREIGN KEY 指明哪些列是外码
- REFERENCES 指明外码参照了哪些表的主码

### 例 3
    CREATE TABLE SC (
    Sno CHAR(9) NOT NULL,
    Cno CHAR(4) NOT NULL,
    Grade SMALLINT,
    PRIMARY KEY (Sno, Cno),
    FOREIGN KEY (Sno) REFERENCES Student(Sno),
    FOREIGN KEY (Cno) REFERENCES Course(Cno)
    );

### 参照完整性检查
- 在 SC 表和 Student 表之间
- Student 删除元组
- Student 修改主码值
- SC 插入元组
- SC 修改外码值

### 违约处理
- 拒绝 (NO ACTION) 执行
- 级联 (CASCADE) 操作
- 设置为空值

### 参照完整性违约处理
- 在 SC 表和 Student 表之间
- Student 删除元组 拒绝/级联删除/设置为空值
- Student 修改主码值 拒绝/级联删除/设置为空值
- SC 插入元组 拒绝
- SC 修改外码值 拒绝

### 创建参照表时明确指定
- CREATE TABLE SC (
- Sno CHAR(9),
- Cno CHAR(4),
- Grade SMALLINT,
- PRIMARY KEY (Sno, Cno),
- FOREIGN KEY (Sno) REFERENCES Student(Sno)
- ON DELETE CASCADE ON UPDATE CASCADE,
- FOREIGN KEY (Cno) REFERENCES Course(Cno)
- ON DELETE NO ACTION ON UPDATE CASCADE
- );

### 用户定义的完整性
- 针对特定应用中数据必须满足的语义要求
- 关系数据库管理系统提供了定义和检验这类完整性的机制

### 属性上的约束条件
- 在 CREATE TABLE 语句中定义
- 列值非空 (NOT NULL)
- 列值唯一 (UNIQUE)
- 检查列值是否满足条件表达式 (CHECK)

### 例 8 改
- CREATE TABLE SC (
- Sno CHAR(9) NOT NULL,
- Cno CHAR(4) NOT NULL,
- Grade SMALLINT CHECK (Grade >= 0 AND Grade <= 100),
- PRIMARY KEY (Sno, Cno),
- FOREIGN KEY (Sno) REFERENCES Student(Sno),
- FOREIGN KEY (Cno) REFERENCES Course(Cno)
- );

### 属性上约束条件的检查
- 在插入元组或修改属性值时检查
- 如不满足则拒绝执行

### 元组上的约束条件
- 在CREATE TABLE语句中使用CHECK短语
- CREATE TABLE Student (
- Sno CHAR(9),
- Sname CHAR(8) NOT NULL,
- Ssex CHAR(2),
- Sage SMALLINT,
- Sdept CHAR(20),
- PRIMARY KEY (Sno),
- CHECK (Ssex = '女' OR Sname NOT LIKE 'Ms.%')
- );

### 元组上约束条件的检查
- 在插入元组或修改属性值时检查
- 如不满足则拒绝执行

6. 数据库保护
6.3 数据库恢复技术

### 事务
- 用户定义的一个数据库操作序列
- 是不可分割的工作单位
- 以 BEGIN TRANSACTION 开始
- 以 COMMIT 或 ROLLBACK 结束

### 事务的 ACID 特性
- 原子性: 是数据库工作的最小单位
- 一致性: 从一个一致性状态变到另一个
- 隔离性: 执行不能被其他事务干扰
- 持久性: 对数据库的改变是永久的

### 数据库恢复
- 将数据库从错误状态恢复到正确状态的功能
- 数据库恢复的基本原理是冗余

### 故障的种类
- 事务内部故障
- 系统故障
- 介质故障
- 计算机病毒

### 事务内部故障
- BEGIN TRANSACTION
- BALANCE = BALANCE - AMOUNT;
- IF (BALANCE < 0 ) THEN
- {PRINT "INSUFFICIENT FUNDS";
- ROLLBACK;}
- ELSE
- {BALANCE1 = BALANCE1 + AMOUNT;
- COMMIT;}
- 当事务没有到达 COMMIT 或 ROLLBACK 语句时
- 意味着出现事务故障

### 系统故障
- 造成系统停止运转的事件
- 如硬件错误, 操作系统故障, DBMS代码错误等
- 影响所有正在运行的事务, 但不破坏数据库
- 需要在系统重新启动后撤销未完成的事务并重做已提交的事务

### 介质故障
- 指外存故障
- 磁盘损坏, 磁头碰撞等
- 会破坏数据库
- 影响正在存取这部分数据的所有事务
- 需要将数据库从备份或日志中重建

### 计算机病毒
- 一种人为的故障或破坏
- 可以繁殖和传播
- 对计算机系统和数据库造成危害
- 使用病毒防护软件诊断和消除

### 总结
- 有些故障会破坏数据库本身
- 有些故障会导致数据不正确
- 数据库恢复需要在不影响其他事务运行的情况下, 将数据库恢复到正确状态

### 恢复的实现技术
- 如何建立冗余数据
- 如何利用这些冗余数据实施数据库恢复

### 数据转储
- DBA 定期地将整个数据库复制到其他存储介质上保存
- 备用的数据称为后备副本 (backup) 或后援副本

### 静态转储
- 在系统中无运行事务时进行的转储操作
- 简单, 但会降低数据库可用性

### 动态转储
- 转储期间允许对数据库进行存取或修改
- 必须把转储期间各事务对数据库的修改登记下来, 建立日志文件 (logfile)

### 海量转储
- 每次转储全部数据库
- 恢复会更方便

### 增量转储
- 每次只转储上一次转储后更新过的数据
- 更节省空间
- 通常更实用

### 日志文件
- 用来记录事务对数据库的更新操作的文件
- 以记录为单位
- 以数据块为单位

### 以记录为单位
- 各个事务的开始 (BEGIN TRANSACTION) 标记
- 各个事务的结束 (COMMIT 或 ROLLBACK) 标记
- 各个事务的所有更新操作
- 被称作日志记录 (log record)

### 日志记录的内容
- 事务标识 (标明是哪个事务)
- 操作的类型 (插入, 删除或修改)
- 操作对象 (记录内部标识)
- 更新前数据的旧值 (对插入操作而言, 此项为空值)
- 更新后数据的新值 (对删除操作而言, 此项为空值)

### 以数据块为单位
- 事务标识
- 被更新的数据块

### 日志文件的作用
- 事务故障恢复和系统故障恢复必须用日志文件
- 在动态转储方式中必须建立日志文件
- 在静态转储方式中也可以建立日志文件

### 登记日志文件的原则
- 登记的次序严格按并发事务执行的时间次序
- 先写日志文件, 后写数据库

6. 数据库保护
6.4 数据库并发控制

### 并发控制
- 为保证事务的隔离性和一致性
- 数据库管理系统需要正确调度并发操作

### 例 1
- 考虑飞机订票系统中的一个活动序列:
- 甲售票点 (事务 T1) 读出某航班的机票余额 A, 设 A=16
- 乙售票点 (事务 T2) 读出同一航班的机票余额 A, 也为 16
- 甲卖出一张机票, 余额 A=A-1, A 为 15, 把 A 写回数据库
- 乙卖出一张机票, 余额 A=A-1, A 为 15, 把 A 写回数据库
- 导致数据库的不一致

### 并发导致的不一致性
- 丢失修改
- 不可重复读
- 读 "脏" 数据

### 丢失修改 (lost update)
- 两个事务 T1 和 T2 读入同一数据并修改
- T2 提交的结果破坏了 T1 提交的结果
- 导致 T1 的修改丢失

### 不可重复读 (non-repeatable read)
- 事务 T1 读取数据后
- 事务 T2 执行更新操作
- 使 T1 无法再现前一次读取结果

### 不可重复读
- 事务 T1 读取某一数据后, 事务 T2 修改了数据
- 事务 T1 读取某些数据后, 事务 T2 删除了其中部分记录
- 事务 T1 读取某些数据后, 事务 T2 插入了一些记录

### 读 "脏" 数据 (dirty read)
- 事务 T1 修改某一数据并将其写回磁盘
- 事务 T2 读取同一数据后
- 该修改被撤销, 被修改过的数据恢复原值
- T2 读到的数据与数据库中数据不一致

### 常用的并发控制技术
- 封锁 (locking)
- 时间戳 (timestamp)
- 乐观控制法 (optimistic scheduler)
- 多版本并发控制 (multi-version concurrency control, MVCC)

### 封锁协议
- 事务 T 在操作某个数据对象之前
- 向系统发出加锁请求
- 事务 T 释放锁之前
- 其他事务不能更新此数据对象

### 封锁类型有两种
- 排他锁 (exclusive locks, 简称 X 锁)
- 共享锁 (shared locks, 简称 S 锁)

### 排他锁
- 写锁
- 若事务 T 对数据对象 A 加上 X 锁
- 则只允许 T 读取和修改 A
- 其他任何事务都不能再对 A 加任何类型的锁
- 直到 T 释放 A 上的锁为止
- 保证其他事务在释放锁之前不能再读取和修改 A

### 共享锁
- 读锁
- 若事务 T 对数据对象 A 加上 S 锁
- 则事务 T 可以读 A 但不能修改 A
- 其他事务只能再对 A 加 S 锁而不能加 X 锁
- 直到 T 释放 A 上的 S 锁为止
- 保证其他事务可以读 A 但不能修改 A

### 封锁协议 (locking protocol)
- 对封锁方式制定不同的规则
- 三级封锁协议
- 不同级别的封锁协议获得不同的系统一致性级别

### 一级封锁协议
- 事务 T 在修改数据 R 之前必须先对其加 X 锁
- 直到事务结束才释放
- 事务结束包括 COMMIT 和 ROLLBACK
- 可防止丢失修改
- 并保证事务T是可恢复的

### 二级封锁协议
- 在一级封锁协议基础上
- 增加事务 T 在读取数据 R 之前必须先对其加 S 锁
- 读完后即可释放 S 锁
- 二级封锁协议防止丢失修改
- 进一步防止读 "脏" 数据

### 三级封锁协议
- 在一级封锁协议的基础上
- 增加事务 T 在读取数据 R 之前必须先对其加 S 锁
- 直到事务结束才释放
- 防止丢失修改和读 "脏" 数据
- 进一步防止了不可重复读

### 活锁
- 当事务 T1 锁定了数据 R
- 事务 T2 请求锁定 R, 导致 T2 等待
- 事务 T3 请求锁定 R, 系统批准了 T3 的请求, T2 仍然等待
- 事务 T4 请求锁定 R, 系统批准了 T4 的请求, T2 仍然等待
- T2 可能永远等待下去

### 避免活锁
- 先来先服务策略
- 封锁子系统按照请求锁的先后顺序对事务排队
- 批准队列中的第一个事务获得锁

### 死锁
- 事务 T1 锁定了数据 R1, 事务 T2 锁定了数据 R2
- T1 请求锁定 R2, T1 等待 T2 释放 R2 上的锁
- T2 申请锁定 R1, T2 等待 T1 释放 R1 上的锁
- T1 和 T2 两个事务永远无法结束

### 解决死锁问题
- 预防死锁
- 允许死锁发生, 但定期诊断与解除

### 预防死锁
- 一次封锁法
- 顺序封锁法

### 一次封锁法
- 每个事务一次性将所有要使用的数据全部加锁
- 降低了系统的并发度
- 难以事先确定事务需要封锁的数据对象

### 顺序封锁法
- 预先对数据对象规定封锁顺序, 如逐级封锁
- 维护封锁顺序非常困难
- 难以事先确定每个事务需要封锁的对象

### 死锁的诊断与解除
- 超时法
- 事务等待图法

### 超时法
- 如果事务等待时间超过规定时限就认为发生死锁
- 有可能误判死锁
- 如果设置的时限过长则无法及时发现死锁

### 事务等待图法
- 有向图
- 节点表示正运行的事务
- 边表示事务之间的等待关系
- 并发控制子系统周期性地生成事务等待图
- 如果图中存在回路则表示发生了死锁
- 选择撤销代价最小的事务

### 并发调度的可串行性
- 可串行化调度
- 执行结果与按照某一顺序串行执行这些事务的结果相同

### 可串行化调度的特性
- 读-写约束
- 写-写约束
- 读-写依赖

### 读-写约束
- 一个事务 T1 读取了一个数据项 X
- 在 T1 写入 X 之前
- 任何事务 T2 都不得对 X 进行写操作

### 写-写约束
- 一个事务 T1 对一个数据项 X 进行了写操作
- 在 T1 提交之前
- 任何事务 T2 都不得对 X 进行写操作

### 读-写依赖
- 如果事务 T1 在读取一个数据项 X 的同时
- 事务 T2 对 X 进行了写操作
- 并且 T1 在 T2 提交之前完成
- 那么 T1 的读操作必须重新执行

### 二段锁协议
- 扩展或生长阶段 (growing phase)
- 收缩或缩减阶段 (shrinking phase)

### 扩展阶段
- 事务在执行过程中逐渐获取所需的锁
- 一旦释放了就不能再获取新的锁

### 收缩阶段
- 在执行过程中释放已经持有的锁
- 一旦释放了就不能再获取新的锁
