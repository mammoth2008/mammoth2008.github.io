4. 关系数据理论
4.2 规范化

函数依赖
- 设 $R$ 是属性集 $U$ 上的关系模式,  $X, Y$ 是 $U$ 的子集. 若对于 $R$ 中的任何一个可能的关系 $r$ ,  $r$ 中不可能存在两个元组在 $X$ 上的属性值相等, 而在 $Y$ 上的属性值不等, 则称** $X$ 函数确定 $Y$ 或 $Y$ 函数依赖于 $X$ , 记作 $X \to Y$ **
- 若 $X \to Y$, 但 $Y \subseteq X$, 则称 $X \to Y$ 是平凡的函数依赖
- 若 $X \to Y$, 但 $Y \nsubseteq X$, 则称 $X \to Y$ 是非平凡的函数依赖

函数依赖
- 若 $X \to Y$, 则 $X$ 是这个函数依赖的决定属性组
- 若 $X \to Y$, $Y \to X$, 则记作 $X \gets \to Y$
- 若 $Y$ 不函数依赖于 $X$, 则记作 $X \nrightarrow Y$

函数依赖
- 函数依赖是语义范畴的概念
- 设计者也可以对现实世界作强制性规定
- 函数依赖是指 $R$ 的一切关系均要满足的约束条件

完全/部分函数依赖
- 设 $R$ 是属性集 $U$ 上的关系模式, $X, Y$ 是 $U$ 的子集. 若 $X \to Y$, 且对于 $X$ 的任何一个真子集 $X'$, $X' \nrightarrow Y$, 则称** $Y$ 对 $X$ 完全函数依赖**, 记为 $X \xrightarrow{F} Y$
- 若 $X \to Y$, 但 $Y$ 不完全函数依赖于 $X$, 则称** $Y$ 对 $X$ 部分函数依赖**, 记为 $X \xrightarrow{P} Y$

传递函数依赖
- 在 $R(U)$ 中, 若 $X \to Y$ 且 $Y \nsubseteq X$, $Y \nrightarrow X$, $Y \to Z$, $Z \nsubseteq Y$, 则称** $Z$ 对 $X$ 传递函数依赖**, 记为 $X \xrightarrow{传递} Z$

码
- 设 $K$ 为关系模式 $R(U)$ 中的属性或属性组合, 若 $K \xrightarrow{F} U$, 则称 $K$ 为 $R$ 的**候选码**
- 若 $U$ 部分函数依赖于 $K$，即 $K \xrightarrow{P} U$, 则 $K$ 称为**超码**
- 若候选码多于一个, 则选定其中的一个为**主码**
- 包含在任何一个候选码中的属性称为**主属性**
- 不包含在任何候选码中的属性称为**非主属性**
- 整个属性组是码则称为**全码**

外码
- 设关系模式 $R$ 中的属性或属性组 $X$ 并非 $R$ 的码, 但 $X$ 是另一个关系模式的码, 则称 $X$ 是 $R$ 的**外码**

范式
- 范式是关系数据库中的一种标准化级别
- 关系数据库中的关系满足不同程度的要求
- 不同程度的要求叫作不同的范式

规范化
- 一个低一级范式的关系模式可以通过模式分解转换为若干个高一级范式的关系模式集合
- 这个过程就是规范化
- 规范化将不符合特定范式的关系模式转换为满足特定范式要求的模式

2NF
- 若关系模式 $R \in 1NF$, 并且每一个非主属性完全函数依赖于任何一个候选码，则 $R \in 2NF$

例6.4：考虑关系模式S-L-C(Sno, Sdept, Sloe, Cno, Grade)，其中Sloe表示学生的住处，每个系的学生住在同一个地方。S-L-C的候选码为(Sno, Cno)。存在以下函数依赖：

(Sno, Cno) → Grade
Sno → Sdept
(Sno, Cno) → Sloe
Sdept → Sloe

函数依赖关系如图6.3所示。图中用虚线表示部分函数依赖。另外，Sdept还函数依赖于Grade。

函数依赖的问题导致了以下几个问题：
1. 插入异常：当要插入一个学生Sno=S7，Sdept=PHY，Sloe=BLD2时，但该生还未选课，即这个学生无Cno，这样的元组无法插入S-L-C中。
2. 删除异常：假设某个学生只选一门课，如S4只选了一门课C3，现在不再选择C3，那么C3这个数据项就要被删除。由于C3是主属性，删除C3会导致整个元组一起被删除，从而删除了不应删除的信息。
3. 修改复杂：某个学生从数学系(MA)转到计算机科学系(CS)，这本来只需修改此学生元组中的Sdept分量即可，但由于关系模式S-L-C中还含有学生的住处Sloe属性，学生转系将同时改变住处，因此还必须修改元组中的Sloe分量。此外，如果这个学生选修了多门课，Sdept、Sloe重复存储了多次，不仅存储冗余度大，而且修改时必须无遗漏地修改所有元组中的全部Sdept、Sloe信息，使得修改变得复杂化。

为了解决以上问题，可以将关系模式S-L-C分解为两个关系模式：SC(Sno, Cno, Grade)和S-L(Sno, Sdept, Sloe)。

关系模式SC的候选码为(Sno, Cno)，关系模式S-L的候选码为Sno，这样就使得非主属性对候选码都是完全函数依赖了。

6.2.5 3NF

定义6.7：若关系模式R(U, F)满足1NF，并且R中不存在这样的码X、属性组Y及非主属性Z(Z=U-X-Y)，使得X

-Y成立且Y+Z，则R满足3NF。

从定义6.7可以推导出，若关系模式R满足3NF，则每一个非主属性既不传递依赖于码，也不部分依赖于码。也就是说，如果R满足3NF，则必有R满足2NF。

在图6.4中，关系模式SC没有传递依赖，而图6.5中关系模式S-L存在非主属性对码的传递依赖。在S-L中，由Sno→Sdept (Sdept→Sno)可得到Sno→Sdept。因此，关系模式S-L满足3NF，而S-L-C不满足2NF。

若一个关系模式R不满足3NF，就会产生与2NF相类似的问题，包括插入异常、删除异常和修改复杂。

解决这些问题的办法是将S-L-C分解为S-D(Sno, Sdept)和D-L(Sdept, Sloe)，分解后的关系模式S-D与D-L中不再存在传递依赖。

6.2.6 BCNF

BCNF (Boyce-Codd Normal Form)由Boyce和Codd提出，是比3NF更进一步的范式，有时也称为扩展的3NF。

定义6.8：若关系模式R(U, F)满足1NF，并且对于R中的每一个非平凡的函数依赖X→Y，X必含有码，则R(U, F)满足BCNF。

换句话说，关系模式R(U, F)满足BCNF，当且仅当每一个决定因素都包含码。

由BCNF的定义可以得出以下结论：
- 所有非主属性对每一个码都是完全函数依赖。
- 所有主属性对于每一个不包含它的码也是完全函数依赖。
- 没有任何属性完全函数依赖于非码的任何一组属性。

由于满足BCNF的关系模式排除了属性对码的传递依赖和部分依赖，所以满足BCNF的关系模式必然满足3NF。

需要注意的是，虽然满足3NF的关系模式必然满足BCNF，但满足3NF的关系模式未必满足BCNF。

下面举例说明一些满足3NF但不满足BCNF的关系模式。

例6.5：考虑关系模式C(Cno, Cname, Pcno)，它只有一个码Cno。在这种情况下，不存在任何属性对Cno的部分依赖或传递依赖，所以C满足3NF。同时，C中Cno是唯一的决定因素，所

以C满足BCNF。

例6.6：关系模式S(Sno, Sname, Sdept, Sage)，假设Sname也具有唯一性，那么S有两个码，这两个码都由单个属性组成，彼此不相交。其他属性不存在对码的传递依赖或部分依赖，所以S满足3NF。同时，S中除了Sno和Sname外没有其他决定因素，所以S也满足BCNF。

以上是一些例子，展示了满足3NF的关系模式有些满足BCNF，有些不满足BCNF。对于不满足BCNF的关系模式，仍然存在一些不合适的地方。读者可以自行举例指出这些关系模式的不合适之处。非BCNF的关系模式也可以通过分解为BCNF来进行改进，例如关系模式STJ可分解为ST(S, T)和TJ(T, J)，它们都满足BCNF。

3NF和BCNF是在函数依赖的条件下衡量模式分解程度的指标。如果一个模式中的所有关系模式都满足BCNF，那么在函数依赖范畴内它已经实现了彻底的分离，已经消除了插入和删除的异常。3NF的不完全性体现在可能存在主属性对码的部分依赖和传递依赖。

6.2.7 多值依赖

以上讨论都是在函数依赖的范畴内进行的。满足BCNF的关系模式是否就是完美的呢？下面来看一个例子。

例6.9：学校中某一门课程由多个教师讲授，他们使用相同的一套参考书。每个教师可以讲授多门课程，每种参考书可以供多门课程使用。初始的关系表如表6.3所示。

为了规范化这张表，可以将其转化为一个规范化的二维表，如表6.4所示。

在多值依赖的情况下，一个属性的值不仅依赖于其他属性的值，还依赖于其他属性组的值。多值依赖的有效性取决于属性集的范围。多值依赖具有对称性和传递性的特点。与函数依赖相比，多值依赖的有效性和定义上的约束更加复杂。

以上是关于规范化的讨论，其中包括了2NF、3NF、BCNF和多值依赖的概念及其在关系模式中的应用。规范化是一种重要的数据库设计技术，用于消除冗余和不一致，并提高数据的一致性和效率。在实际的数据库设计过程中，根据具体的业务需求和数据特点，可以选择不同的范式来进行规范化，以达到合理和有效的数据库设计。

6.2.8 4NF

定义6.10：关系模式R<U, F>如果对于R的每个非平凡多值依赖X -> Y (X包含码)，则称R<U, F>满足4NF。4NF限制了关系模式中非平凡且非函数依赖的多值依赖。根据定义，对于每个非平凡的多值依赖X -> Y，X都包含候选码，因此4NF允许的非平凡多值依赖实际上是函数依赖。

显然，如果一个关系模式是4NF，那么它必然是BCNF。

对于之前讨论的关系模式WSC，它不是码，关系模式WSC的码是(Sno, C)，即全键。因此WSC满足4NF。

一个关系模式如果已达到了BCNF但不是4NF，这样的关系模式仍然具有不好的性质。以WSC为例，WSC满足BCNF，但是WSC不满足4NF。对于WSC的某个关系，如果某一仓库仍有多个保管员，存放相同物品，则关系中元组数目一定会有m×n个。每个保管员重复存储多次，每种物品重复存储多次，数据的冗余度太大，因此还应该继续规范化使WSC满足4NF。

可以使用投影分解的方法来消除非平凡且非函数依赖的多值依赖。例如，可以将WSC分解为WS(S, C)和WC(W, C)。在WS中虽然存在不平凡的多值依赖，但这是平凡的多值依赖。WS中已经不存在非平凡的非函数依赖的多值依赖，所以WS满足4NF，同理WC也满足4NF。

函数依赖和多值依赖是两种最重要的数据依赖。如果只考虑函数依赖，则满足BCNF的关系模式已经达到了最高程度的规范化；如果考虑多值依赖，则满足4NF的关系模式达到了最高程度的规范化。除了函数依赖和多值依赖之外，还存在其他类型的数据依赖，如连接依赖。函数依赖是多值依赖的特殊情况，而多值依赖实际上又是连接依赖的特殊情况。但是，连接依赖不像函数依赖和多值依赖那样可以直接由语义推导出来，而是在关系的连接操作时才显现出来。存在连接依赖的关系模式

仍然可能遇到数据冗余和插入、修改、删除异常等问题。如果消除了满足4NF的关系模式中存在的连接依赖，则可以进一步达到5NF的关系模式。这里不再讨论连接依赖和5NF，有兴趣的读者可以参阅相关书籍。

6.2.9 规范化小结

在关系数据库中，对关系模式的基本要求是满足第一范式，这样的关系模式是合法且允许的。但是，人们发现有些关系模式存在插入、删除异常，以及修改复杂、数据冗余等问题，需要寻求解决这些问题的方法，这就是规范化的目的。

规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的"分离"，即"一事一地"的模式设计原则。让一个关系描述一个概念、一个实体或者实体间的一种联系。若多于一个概念就把它"分离"出去。因此，规范化实质上是概念的单一化。

人们对规范化的认识经历了一个过程，从认识非主属性的部分函数依赖的危害开始，2NF、3NF、BCNF、4NF的相继提出标志着这个认识过程逐步深化。消除决定因素非码的非平凡函数依赖是1NF，消除非主属性对码的部分函数依赖是2NF，消除非主属性对码的传递函数依赖是3NF，消除主属性对码的部分和传递函数依赖是BCNF，消除非平凡且非函数依赖的多值依赖是4NF。图6.8概括了这个过程。

规范化过程是通过对关系模式的分解来实现的，即将低一级的关系模式分解为若干个高级的关系模式。这种分解不是唯一的。下面将进一步讨论分解后的关系模式与原关系模式的"等价"问题以及分解的算法。

6.3 数据依赖的公理系统

数据依赖的公理系统是模式分解算法的理论基础。首先讨论函数依赖的一个有效而完备的公理系统，即Armstrong公理系统。

定义6.11：对于满足一组函数依赖F的关系模式R<U, F>，如果对R中的任意两个元组t、s，若对于F中的每个函数依赖X -> Y

，若t[X] = s[X]，则必有t[Y] = s[Y]，则称F逻辑蕴含于F。

为了求得给定关系模式的码，或者从一组函数依赖求得蕴含的函数依赖，例如已知函数依赖集F，要判断X -> Y是否为F所蕴含，就需要一套推理规则。这组推理规则是1974年由Armstrong首先提出的。

Armstrong公理系统包括以下三条推理规则：
A1 自反律（reflexivity rule）：若Y包含于X，则X -> Y属于F。
A2 增广律（augmentation rule）：若X -> Y属于F，且Z是属性集U的子集，则XZ -> YZ属于F。
A3 传递律（transitivity rule）：若X -> Y属于F，且Y -> Z属于F，则X -> Z属于F。

Armstrong公理的有效性指的是由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F中；完备性指的是F中的每一个函数依赖必定可以由F出发根据Armstrong公理推导出来。

判定函数依赖是否属于由F根据Armstrong公理推导出的函数依赖集合的问题可以转化为判定X+是否为X的子集的问题，其中X+是X关于函数依赖集F的闭包。可以使用算法6.1来解决这个问题。

算法6.1：求属性集X关于函数依赖集F的闭包X+
输入：X，F
输出：X+
步骤：
1. 令X+ = X, i = 0
2. 求B，其中B = {A | (∃V)(∃W)(V = W且VX = WX)，且X ∈ X+}
3. 判断X+ = X(i)。如果相等或X+ = U，则X(i)就是X+。
4. 若不相等，则i = i + 1，返回步骤2。

算法6.1最多经过|U|次循环就会终止，其中|U|表示属性集U中的属性个数。

定理6.2：Armstrong公理系统是有效的且完备的。Armstrong公理系统的有效性可以由定理6.1得到证明。完备性说明了由F出发根据Armstrong公理推导出来的函数依赖集合中的每一个函数依赖都是F的蕴含。

根据Armstrong公理的完备性和有效性，可以将函数依赖集F等价于一个极小函数依赖集。

6.4.1 模式分解的三个定义

对于一个模式的分解是多种多样的，但是分解后产生的模式应与原模式等价。人们从不同的角度去观察问题，对"等价"的概念形成了三种不同的定义：

1. 分解具有无损连接性（lossless join）。
2. 分解要保持函数依赖（preserve functional dependency）。
3. 分解既要保持函数依赖，又要具有无损连接性。

这三个定义是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度。

本节要讨论的问题是：
1. 无损连接性和保持函数依赖的含义是什么？如何判断？
2. 对于不同的分解等价定义究竟能达到何种程度的分离，即分离后的关系模式是第几范式。
3. 如何实现分离，即给出分解的算法。

先来看两个例子，说明按定义6.16，若只要求R<U,F>分解后的各关系模式所含属性的"并"等于U，这个限定是很不够的。一个关系分解为多个关系，相应地原来存储在一张二维表内的数据就要分散存储到多张二维表中，要使这个分解有意义，起码的要求是后者不能丢失前者的信息。

[例6.14] 已知关系模式R<U,F>，其中U={Sno,Sdept,Mname}，F={Sno->Sdept,Sdept->Mname}。R<U,F>的元组语义是学生Sno正在Sdept系学习，其系主任是Mname；并且一个学生(Sno)只在一个系学习，一个系只有一名系主任。R的一个关系见表6.7所示。

由于R中存在传递函数依赖Sno->Mname，它会发生更新异常。例如，如果S4毕业，则D3系的系主任王一的信息也就丢掉了。反过来，如果一个系D5尚无在校学生，那么这个系的系主任赵某的信息也无法存入。于是进行了如下分解：

R1=<Sno, Sdept>
R2=<Sdept, Mname>

可以证明R1对R的分解是可恢复的，但是前面提到的插入和删除异常仍然没有解决，原因就在于原来在R中存在的函数依赖Sdept->Mname，现在在R1和R2中都不再存在。

最后对R进行了以下分解：

R

3=<Sno, Sdept>
R4=<Sdept, Mname>

可以证明分解R3和R4既具有无损连接性，又保持函数依赖。它解决了更新异常的问题，又没有丢失原数据库的信息，这是所希望的分解。由此可以看出为什么要提出对数据库模式"等价"的三个不同定义的原因。

下面严格地定义分解的无损连接性和保持函数依赖性，并讨论它们的判别算法。

6.4.2 分解的无损连接性和保持函数依赖性

先定义一个记号：设p={Ri<Ui, Fi>, ..., Rk<Uk, Fk>}是R<U, F>的一个分解，r是R的一个关系。定义mp(r)=∏(r)，即mp(r)是r在p中各关系模式上投影的连接。这里∏(r)表示r的投影，∏(r)={t|∃t∈r，t的属性只有∏中的属性}。

引理6.4 设mp(r)=X，则一个关系模式q={R<U, F>}的一个分解p={Ri<Ui, Fi>, ..., Rk<Uk, Fk>}是R<U, F>的一个分解，r是R的一个关系。则有：
(1) r⊆mp(r)。
(2) 若s=mp(r)，则mp(s)=r。
(3) mp(mp(r))=mp(r)。

证明：
(1) 证明r中的任何一个元组属于mp(r)。
任取r中的一个元组t，设t的属性集为X。由于p是R<U, F>的一个分解，所以t在p中的每个关系模式上的投影都属于该模式，即t在mp(r)中。
(2) 由(1)得到r⊆mp(r)。已设s=mp(r)，则对任意t∈R(r)，必有t∈mp(r)。现只需证明mp(s)⊆r，就有mp(s)=r。
任取s中的一个元组u，必有u∈mp(r)，根据自然连接的定义，存在r中的一个元组v，使得v⊆u。由前面证得r⊆mp(r)，故v∈R(r)，故u∈R(s)。故mp(s)⊆r。
(3) 由(2)得到mp(mp(r))=mp(r)。

直接根据定义6.18去鉴别一个分解的无损连接性是不可能的，算法6.2给出了一种判断方法。

算法6.2 判别一个分解的无损连接性。
p={R1<U1, F1>, ..., Rk<Uk, Fk>}是R<U, F>的一个分解，U={A1, ..., An}，F={FD1, FD2, ..., FDm}，不妨设F是一

极小依赖集，记FD为X1→A1, X2→A2, ..., Xm→Am。

(1) 建立一张m×n的表，每一列对应一个属性，每一行对应分解中的一个关系模式。若属性Ai属于Ri，则在第i列，第j行交叉处填上ai，否则填上□。

(2) 对每一个FDi，做下列操作：找到Xi所对应的列中具有相同符号的那些行，考察这些行中Ui列的元素。若其中有□，则全部改为□：否则全部改为ai。其中j是这些行的行号最小值。应当注意的是，若某个属性Ai被改，那么该表的第i列中凡是□的符号（不管它是否开始找到的那些行）均应作相应的更改。如在某次更改之后，有一行成为□，则p不具有无损连接性。

对每个FD逐一进行一次这样的处理，称为对p的一次扫描。

(3) 比较扫描前后表有无变化，如有变化则返回第(2)步，否则算法终止。如果发生循环，那么前次扫描至少应使该表减少一个符号，表中符号有限，因此循环必然终止。

定理6.4 如果算法6.2终止时表中有一行为□，□, ..., □，则p为无损连接分解。

[例6.15] 已知关系模式R<U,F>，其中U={A,B,C,D,E}，F={AB→C,C→D,D→E}。R的一个分解为R1(A,B,C)，R2(C,D)，R3(A,E)。

首先构造初始表，如图6.9 (a)所示。

然后对AB→C进行操作，因各元组的第一、二列没有相同的分量，所以表不改变。由C→D可以把□改为a3，再由D→E可使b32、c33全改为a3。最后结果为图6.9 (b)，表中第一行成为a1、a2、a3、a4、a5，所以此分解具有无损连接性。

当关系模式R分解为两个关系模式R1、R2时有下面的判定准则。

定理6.5 对于R<U,F>的一个分解p={R1<U1,F1>,R2<U2,F2>}，如果 U1∩U2=∅ 或 U1∪U2≠U，则p具有无损连接性。

定理的证明留给读者完成。

定义6.19 若p={R1<U1,F1>,...,Rk<Uk,Fk>}是R<U,F>的分解，则p具有保持函数依

赖性，当且仅当对F中的每个函数依赖α→β，α∩β=∅，有α⊆Ui 或 β⊆Ui。

算法6.3 给出了判断一个分解是否具有保持函数依赖性的方法。

算法6.3 判断一个分解的保持函数依赖性
p={R1<U1, F1>, ..., Rk<Uk, Fk>}是R<U, F>的一个分解，U={A1, ..., An}，F={FD1, FD2, ..., FDm}。

(1) 建立一张m×n的表，每一列对应一个属性，每一行对应分解中的一个关系模式。若属性Ai属于Ri，则在第i列，第j行交叉处填上ai，否则填上□。

(2) 对每一个FDi，做下列操作：找到Xi所对应的列中具有相同符号的那些行，考察这些行中Ui列的元素。若其中有□，则全部改为□：否则全部改为ai。其中j是这些行的行号最小值。如果有□不能填，那么p不具有保持函数依赖性。

(3) 比较扫描前后表有无变化，如有变化则返回第(2)步，否则算法终止。如果发生循环，那么前次扫描至少应使该表减少一个符号，表中符号有限，因此循环必然终止。

定理6.6 如果算法6.3终止时表中没有□，则p为具有保持函数依赖性的分解。

[例6.16] 已知关系模式R<U,F>，其中U={A,B,C,D,E}，F={AB→C,C→D,D→E}。R的一个分解为R1(A,B,C)，R2(C,D)，R3(A,E)。

首先构造初始表，如图6.10 (a)所示。

然后对AB→C进行操作，因各元组的第一、二列没有相同的分量，所以表不改变。由C→D可以把□改为a3，再由D→E可使b32、c33全改为a3。最后结果为图6.10 (b)，由图可知此分解具有保持函数依赖性。

定理6.7 如果一个分解p={R1<U1, F1>, ..., Rk<Uk, Fk>}具有无损连接性，并且保持F中的所有函数依赖，则p是R<U, F>的一种分解。

6.4.3 按照一种函数依赖分解的算法

设一个函数依赖集F中的一个依赖为α→β。在所有关系模式Ri的U列中，寻找α的取值不相同的行，将其中β所对应的列全部

删除，产生一个新的关系模式。然后再处理新的关系模式，删除其中的冗余属性。将新的关系模式和其冗余属性作为新的关系模式Rj的属性集和依赖集。重复这个过程，直到无法再产生新的关系模式为止。最后，得到的关系模式集就是R<U,F>的一个分解。

[例6.17] 设有关系模式R<A,B,C,D,E>，函数依赖集F={AB→C,C→D,AD→E,E→B}。

(1) 对于函数依赖AB→C，寻找A、B取值不相同的行。由于A、B取值不相同的行有三行，所以产生一个新的关系模式R1(A,B,C)。

(2) 在R1的基础上，对冗余属性进行处理。由于C→D，所以D是冗余的，将其删除。得到R2(A,B,C)。

(3) 在R2的基础上，对函数依赖C→D进行处理。寻找C取值不相同的行，发现C取值不相同的行只有两行，所以产生一个新的关系模式R3(C,D)。

(4) 在R3的基础上，对冗余属性进行处理。由于无冗余属性，处理完毕。

最终得到的分解为{R1(A,B,C), R3(C,D)}。

蕴涵与完备性是函数依赖和多值依赖的重要概念。完备性指的是在给定的函数依赖或多值依赖集合D中，所有被D蕴涵的依赖关系都可以根据8条公理进行推导得到。换句话说，在函数依赖和多值依赖的条件下，"蕴涵"和"导出"是等价的。

在前面的第6.3节中已经证明了Al、A2、A3的有效性，剩余的有效性证明留给读者自行完成。通过使用8条公理，可以得到以下4条有用的推理规则：

(1) 合并规则：如果有X→Y和X→Z，则可以推导出X→XZ。

(2) 伪传递规则：如果有X→Y和Y→Z，则可以推导出X→Z。

(3) 混合伪传递规则：如果有X→Y和X/Y→Z，则可以推导出X→Z。

(4) 分解规则：如果有X→Y和X→Z，则可以推导出X→YZ。

本章讨论了关系模式的规范化，在函数依赖和多值依赖的范畴内。基本思想可以用图6.11表示。在整个讨论过程中，只使用了两种关系运算：投影和自然连接，并且总是从一个关系模式出发进行分解。在定义"等价"时，是指一组关系模式与一个关系模式的"等价"。也就是说，在问题讨论的开始阶段，假设存在一个单一的关系模式，即泛关系假设。

图6.11总结了关系模式规范化的步骤，包括1NF、2NF、3NF、BCNF和4NF。本章一开始就指出，这是研究模式设计的一种特殊情况，即已知一个模式S0，问题是设计一个模式SD，使其与S0等价，并在某些方面更好。泛关系假设在应用规范化理论时是一个障碍，因为它等于承认了现实世界中各实体之间只能存在一种联系，而这通常是不现实的。为了解决这个问题，人们提出了一些方法，例如建立不受泛关系假设限制的理论，或者通过某些手段使现实世界与信息世界的转换适应泛关系的要求。

最后要强调的是，规范化理论为数据库设计提供了理论指导和工具，但它只是提供了指南和工具，并不意味着规范化程度越高的模式就越好。在

选择数据库模式时，必须合理考虑应用环境和现实世界的具体情况。


