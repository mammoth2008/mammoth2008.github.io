8. 数据结构与算法概论
8.1 什么是数据结构

### 本章学习目标
- 数据结构的定义
- 逻辑结构, 存储结构, 运算的相互关系
- 各种逻辑结构之间的差别
- 各种存储结构之间的差别
- 数据结构和数据类型的区别和联系
- 抽象数据类型的概念和描述方式
- 算法的定义和特性
- 算法的时间复杂度和空间复杂度分析

### 用计算机解决问题
- 完成对现实世界问题的抽象
- 了解待处理对象的特性及其之间的关系
- 将现实世界的问题转化为**数学问题**

### 为什么是数学
- 因为数学有严密的符号表述体系
- 有严密确定的推理系统

### 有穷观点的能行方法
- 大卫·希尔伯特 (David Hilbert)
- 由有限数量的明确有限指令构成
- 指令执行在有限步骤后终止
- 指令每次执行都总能得到唯一结果
- 原则上可以由人单独采用纸笔完成
- 每条指令可以机械地被精确执行

### 图灵机 (Turing Machine)
- 一条无限长的纸带
- 一个读写头
- 一套控制规则数量有限的命令表
- 一个状态寄存器

### 人类面临的问题
- 是什么? 通过树状分类解决
- 为什么? 通过推理规则解决
- 怎么做? 通过**特定流程**解决

### 程序设计的实质
- 对确定的问题选择一种好的**数据结构**
- 设计一种好的**算法**
- 数据结构即一组拥有特定关系的数据
- 算法即一个有限长的操作序列

### 计算机解决问题的基本流程
- 分析问题, 确定数据模型
- 设计相应算法
- 编写, 运行并调试程序
- 得到正确的结果

### 数据 (Data)
- 是描述客观事物的数和字符的集合
- 计算机操作的对象的总称
- 计算机所处理信息的某种特定的符号表示形式

### 数据元素 (Data Element)
- 数据的基本单位
- 有时数据元素也称为元素, 结点, 顶点或记录
- 可以由若干个数据项组成

### 数据项 (Data Item)
- 具有独立含义的数据最小单位
- 也称为字段或域

### 数据对象 (Data Object)
- 性质相同的数据元素的集合
- 数据的一个子集
- 本课程中讨论的数据通常是指数据对象

### 数据结构 (Data Structure)
- 所有数据元素以及数据元素之同的关系
- 带结构的数据元素的集合

### 数据结构的组成
- 逻辑结构 (Logical Structure)
- 数据的存储结构 (Storage Structure)
- 运算 (Operation)

### 逻辑结构
- 从逻辑关系上描述数据
- 问题的抽象模型
- 与计算机无关

### 存储结构
- 在计算机中的实现
- 数据元素之间的关系在计算机中的表示
- 依赖于计算机语言

### 运算
- 对数据的基本操作
- 定义在逻辑结构上
- 依赖于存储结构

### 数据结构
- 描述现实世界实体的数学模型 (通常为非数值计算) 及其之上的运算在计算机中如何表示和实现

### 逻辑结构的表示
- 图表
- 二元组

### 图表
- 用表格或者图形直接描述数据的逻辑关系
- 表格
- 线性表
- 树
- 图

### 二元组
- $B = (D, R)$
- $B$是一种数据逻辑结构
- $D$是数据元素的集合
- $R$是$D$上二元关系的集合
- $D = \lbrace d\_i, | 0 \leq i \leq n-1, n \geq 0 \rbrace $
- $R = \lbrace r\_j, | 1 \leq j \leq m, m \geq 0 \rbrace $

### 逻辑结构中的数据
- 关系$r\_j (1 \leq j \leq m)$是$D$上是序偶的集合
- 对$r\_j$中的任意序偶$<x, y>(x, y \in D)$
- $x$叫做第一元素或$y$的前驱元素
- $y$叫做第二元素或$x$的后继元素
- 若某元素没有前驱, 则称为开始元素
- 若某元素没有后继, 则称为终端元素
- 对称序偶用圆括号表示, 如$(x, y) \in r$

### 逻辑结构的类型
- 集合
- 线性结构
- 树形结构
- 图形结构

### 集合
- 只有 "同属于一个集合" 的关系

### 线性结构
- 若非空，则只有一个开始元素和一个终端元素
- 除终端元素外，每个元素都有一个后继元素
- 除开始元素外，每个元素都有一个前驱元素

### 树形结构
- 若非空，则只有一个开始元素
- 每个元素有零个或多个后继元素
- 除开始元素外, 每个元素都有一个前驱元素

### 图形结构
- 每个元素可以有多个后继元素
- 每个元素可以有多个前驱元素

### 数据的存储结构
- 存储数据元素
- 存储逻辑关系

### 常见存储结构
- 顺序存储结构
- 链式存储结构
- 索引存储结构
- 散列存储结构

### 顺序存储
- 使用一片地址连续的存储单元
- 数据元素的存储位置相邻

    class Stud1
    {
        int no;
        String name;
        int score; 
        public Stud1(int no1,String name1,int score1)
        {
            no=no1; name=name1; score=score1;
        }
        public void disp()
        {
           System.out.println(no+" "+name+" "+score);
        }
    }

### 链式存储
- 使用任意存储单元
- 数据元素的存储位置不一定相邻
- 通过指针存储数据元素之间的逻辑关系

### 索引存储
- 使用两个表: 数据表, 索引表
- 索引表中每个元素都包含一个指针
- 指针指向数据表中的某个元素

### 散列存储 (hash)
- 用哈希函数将数据元素关键字映射到地址上
- 地址称为散列 (哈希) 地址
- 散列地址与数据元素的逻辑关系无关

### 数据的运算
- 运算是指对数据实施的操作
- 功能描述
- 功能实现

### 功能描述
- 基于逻辑结构
- 用户定义的
- 抽象的

### 功能实现
- 基于存储结构
- 程序员实现的
- 具体的
- 等同于算法设计

### 数据类型
- 一组性质相同的值的集合
- 定义在此集合上的一些操作

### 抽象数据类型 (Abstract Data Type, ADT)
- 逻辑数据结构的描述
- 逻辑数据结构上的运算

### 抽象数据类型的描述
- 数据对象
- 数据关系
- 基本操作
- $ADT = (D, S, P)$

### 抽象数据类型
- Set
- TwoSet

### Set
- $E$ 类型
- 遵循标准数学定义
- 求集合长度
- 求第 $i$ 个元素
- 判断一个元素是否在集合中
- 向集合中添加一个元素
- 从集合中删除一个元素
- 输出集合中的所有元素

### Set
    ADT Set
    {数据对象:
        $data = \lbrace d\_i | 0 \leq i \leq n-1, d\_i \in E \rbrace;$
        int size;
    数据关系:
        无
    基本运算:
        int getSize();
        E get(int i);
        boolean IsIn(E e);
        boolean add(E e);
        boolean delete(E e);
        void display();
    } ADT Set

### TwoSet
- 集合并
- 集合交
- 集合差

### TwoSet
    ADT TwoSet
    {数据对象:
      $data = \lbrace s\_i | 1 \leq i \leq n, s\_i \in Set \rbrace;$
    数据关系:
      无
    基本运算:
      Union(Set s1, Set s2);
      Intersect(Set s1, Set s2);
      Difference(Set s1, Set s2);
    }

### 抽象数据类型的特征
- 数据抽象
- 数据封装

### 数据抽象
- 本质特征
- 能完成的功能
- 和用户的接口

### 数据封装
- 将外部特征与内部实现分离
- 对用户隐藏实现细节

8. 数据结构与算法概论
8.2 算法及其描述

### 算法
- 算法 (Algorithm) 是对特定问题求解步骤的一种描述
- 是指令的有限序列
- 其中每条指令表示计算机的一个或多个操作

### 算法的特性
- 有穷性
- 确定性
- 可行性
- 有输入
- 有输出

### 有穷性
- 必须总是在执行有穷步之后结束
- 每一步都可在有穷时间内完成

### 确定性
- 对于每种情况下执行的操作在算法中都有确切的规定
- 算法的执行者或阅读者都能明确其含义及如何执行
- 并且在任何条件下算法都只有一条执行路径
- 对于相同的输人只能得出相同的输出

### 可行性
- 所有操作都必须足够基本
- 算法可以通过有限次基本操作来完成其功能

### 有输入
- 输入通常体现为算法中的一组变量
- 一个算法有零个或者多个输入

### 有输出
- 输出是算法进行信息加工后得到的结果
- 一个算法有一个或者多个输出

### 算法和程序的区别
- 程序是使用计算机语言对算法的具体实现
- 即具体要怎么做
- 而算法侧重于对解决问题的方法描述
- 即要做什么
- 算法必须满足有穷性
- 而程序不一定满足有穷性

### 算法描述
- 自然语言
- 流程图
- 伪代码
- 计算机语言

### Java 基础
- 基本数据类型
- 输入输出
- 引用类型
- 类设计
- 创建对象
- 类变量和类方法
- 方法的参数传递
- 泛型
- 继承
- 接口
- 迭代器

### Java 的基本数据类型
- 整型
- 浮点型
- 字符型
- 布尔型

### Java 的输入输出
- 输入类 System.in
- 输出类 System.out

### Java 的引用类型
- 值类型
- 引用类型

### Java 的类设计
- 创建类
- 类成员变量的定义及修饰符
- 方法的声明与实现
- 构造方法

### Java 的创建对象
- 声明对象
- 实例化

### Java 的类变量和类方法
- 类变量
- 实例变量
- 类方法
- 实例方法

### Java 的方法的参数传递
- 形参
- 实参
- 值传递
- 引用传递

### Java 的泛型
- 泛型类
- 参数化类型
- Java 的伪泛型

### Java 的继承
- 分层次的类
- 父类
- 子类

### Java 的接口
- 抽象方法的集合
- 接口包含类要实现的方法

### Java 的迭代器
- 遍历集合中的元素
- iterator() 方法

8. 数据结构与算法概论
8.3 算法分析

### 算法设计的要求
- 正确性
- 可使用性
- 可读性
- 健壮性
- 高效率与低存储量

### 正确性
- 能够正确地执行预先规定的功能和性能要求
- 是最重要也是最基本的标准

### 可使用性
- 能够很方便地使用
- 也叫用户友好性

### 可读性
- 应该易于使人理解
- 逻辑清晰, 简单和结构化

### 健壮性
- 具有好的容错性
- 提供异常处理
- 能够对不合理的数据进行检查
- 不经常出现异常中断或死机

### 高效率与低存储量
- 算法的效率主要指算法执行时间
- 执行时间短的算法效率高
- 存储量指执行过程中所需最大存储空间

### 算法时间性能分析
- 事后统计法
- 事前估算法

### 事后统计法
- 统计程序执行时间
- 与很多因素有关

### 事前估算法
- 顺序结构
- 分支结构
- 循环结构
- 原操作
- 执行时间由原操作的执行次数来计量

### 算法频度
- 所有原操作的执行次数之和
- 用 $T(n)$ 表示

### 方阵相加
    void matrixadd(int[][] A, int[][] B, int[][] C, int n) {
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                C[i][j] = A[i][j] + B[i][j];
    }
- $T(n) = n+1+n(n+1)+n^2 = 2n^2+2n+1 = O(n^2)$

### 算法时间复杂度
- $T(n)$ 的数量级,即 $T(n) = O(f(n))$
- 存在正常量 $C$ 和 $n\_0$
- 使得当 $\lim\limits_{n \to n\_0} \frac{\lvert T(n) \rvert}{\lvert f(n) \rvert} \leq C \ne 0$

### 算法复杂度
    void fun(int n){
      int s = 0;
      for (i = 0; i < n; i++)
          for (j = 0; j < i; j++)
              for (int k = 0; k < j; k++)
                  s++;
      return s;
    }

$$
\begin{eqnarray\*}
T(n) &=& \sum\limits\_{i=0}^n \sum\limits\_{j=0}^i \sum\limits\_{k=0}^{j-1} 1 \\\
&=& \sum\limits\_{i=0}^n \sum\limits\_{j=0}^i (j-1-0+1) = \sum\limits\_{i=0}^n \sum\limits\_{j=0}^i j \\\
&=& \sum\limits\_{i=0}^n \frac{i(i+1)}{2} = \frac{1}{2}(\sum\limits\_{i=0}^n i^2 + \sum\limits\_{i=0}^n i) \\\
&=& \frac{2n^3 + 6n^2 + 4n}{12} = O(n^3)
\end{eqnarray\*}
$$

### 算法的空间复杂度
- 算法的空间复杂度是指算法需要消耗的内存空间
- $S(n) = O(g(n))$

8. 数据结构与算法概论
8.4 数据结构的目标

### 算法的评价标准
- 占用资源越少就越好
- 时间复杂度分析
- 空间复杂度分析

### 存储结构对算法的影响
- 存储能力
- 与算法的适应性

### 抽象数据类型的实现
- Set
- TwoSet

### Set
    class Set<E>
    {
        final int MaxSize=100;
        E[] data;
        int size;
        public Set() 
        {    data = (E[])new Object[MaxSize];
            size=0;
        }

### Set.getsize()
    public int getsize()
    {
        return size;
    }

### Set.get()
    public E get(int i)
    {
        return (E)data[i];
    }

### Set.IsIn()
    public boolean IsIn(E e)
    {
        for (int i=0;i<size;i++)
            if (data[i]==e)
                return true;
        return false;
    }

### Set.add()
    public boolean add(E e)
    {
        if (IsIn(e))
            return false;
        else
        {
            data[size]=e;
            size++;
            return true;
        }
    }

### Set.delete()
    public boolean delete(E e)
    {
        int i=0;
        while (i<size && data[i]!=e) i++;
        if (i>=size) return false;
        for (int j=i+1;j<size;j++)
            data[j-1]=data[j];
        size--;
        return true;
    }

### Set.display()
    public void display()
    {
        for (int i=0;i<size;i++)
        {
            if (i==0)
                System.out.print(data[i]);
            else
                System.out.print(" "+data[i]);
        }
        System.out.println();
    }
- }

### TwoSet.Union()
    {
        public Set<E> Union(Set<E> s1,Set<E> s2) //求s3=s1∪s2
        {
            Set<E> s3=new Set<E>();
            for (int i=0;i<s1.getsize();i++)
                s3.add(s1.get(i));
            for (int i=0;i<s2.getsize();i++)
                if (!s1.IsIn(s2.get(i)))
                    s3.add(s2.get(i));
            return s3;
        }

### TwoSet.Intersection()
    public Set<E> Intersection(Set<E> s1,Set<E> s2)
    {
        Set<E> s3=new Set<E>();
        for (int i=0;i<s1.getsize();i++)
            if (s2.IsIn(s1.get(i)))
                s3.add(s1.get(i));
        return s3;
    }

### TwoSet.Difference()
    public Set<E> Difference(Set<E> s1,Set<E> s2)
    {
        Set<E> s3=new Set<E>();
        for (int i=0;i<s1.getsize();i++)
            if (!s2.IsIn(s1.get(i)))
                s3.add(s1.get(i));
        return s3;
    }
